# -*- coding: utf-8 -*-
"""Milestone4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Sx8dMSeFkdabnS3f_032u1W2Bqpptg4

# Send alert message via email and slack
"""

! pip install pandas sklearn smtplib

"""## Try to send Alert message in Email"""

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report

# 1. Train the Model
def train_model(data_path):
    data = pd.read_csv(data_path)

    # Map target variable to numeric
    data['Action'] = data['Action'].map({'SELL': 0, 'MONITOR': 1, 'BUY': 2})

    # Select features and target
    X = data[['Utilization', 'Risk Score', 'Sentiment Score']]
    y = data['Action']

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Train model
    model = RandomForestClassifier(random_state=42)
    model.fit(X_train, y_train)

    # Evaluate model
    y_pred = model.predict(X_test)
    print("Model Trained. Evaluation:\n", classification_report(y_test, y_pred))

    return model

# 2. Predict Action
def predict_action(model, utilization, risk_score, sentiment_score):
    new_input = pd.DataFrame({
        'Utilization': [utilization],
        'Risk Score': [risk_score],
        'Sentiment Score': [sentiment_score]
    })
    prediction = model.predict(new_input)
    action_map = {0: 'SELL', 1: 'MONITOR', 2: 'BUY'}
    return action_map[prediction[0]]

# 3. Send Email Alert
def send_email_alert(recipient_email, subject, body):
    sender_email = "janabithika1976@gmail.com"
    sender_password = "******"

    # Set up email
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email
    message['Subject'] = subject

    # Add body
    message.attach(MIMEText(body, 'plain'))

    # Send email
    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(message)
            print(f"Alert sent to {recipient_email}")
    except Exception as e:
        print(f"Error sending email: {e}")

# Main function to integrate everything
def main():
    # Train the model
    model = train_model("supply_chain_alerts.csv")

    # User input
    print("Enter Supply Chain Data:")
    utilization = float(input("Utilization (e.g., 0.85 for 85%): "))
    risk_score = float(input("Risk Score (0-10): "))
    sentiment_score = float(input("Sentiment Score (0-10): "))
    recipient_email = input("Recipient Email for Alert: ")

    # Predict action
    action = predict_action(model, utilization, risk_score, sentiment_score)
    alert_subject = f"Supply Chain Alert: Recommended Action - {action}"
    alert_body = f"Action: {action}\nDetails:\nUtilization: {utilization}\nRisk Score: {risk_score}\nSentiment Score: {sentiment_score}"

    # Send email alert
    send_email_alert(recipient_email, alert_subject, alert_body)

if __name__ == "__main__":
    main()

"""## Try to send Alert message in Slack"""

import requests

# Function to send Slack alert
def send_slack_alert(webhook_url, alert_subject, alert_body):
    payload = {
        "text": f"*{alert_subject}*\n{alert_body}"
    }
    try:
        response = requests.post(webhook_url, json=payload)
        if response.status_code == 200:
            print("Alert sent to Slack successfully!")
        else:
            print(f"Failed to send alert to Slack: {response.status_code}")
    except Exception as e:
        print(f"Error sending alert to Slack: {e}")

# Example usage in the main function
if __name__ == "__main__":
    slack_webhook_url = "https://hooks.slack.com/services/your/webhook/tomatosupplyc-ykw5461"

    # Example alert
    alert_subject = "Supply Chain Alert: Recommended Action - BUY"
    alert_body = (
        "Action: BUY\n"
        "Details:\n"
        "Inventory: 5000\n"
        "Lead Time: 7\n"
        "Transport Status: Delayed\n"
        "News Sentiment: Severe disruptions in logistics.\n"
        "Weather Condition: Heavy rainfall.\n"
        "Utilization: 0.50\n"
        "Sentiment: Negative (Score: 0.78)\n"
        "Risk: High (Score: 0.85)"
    )
    send_slack_alert(slack_webhook_url, alert_subject, alert_body)

"""## Though its print successful but not send in slack: Check slack"""

import requests

webhook_url = "http://tomatosupplyc-ykw5461.slack.com/"
message = {"text": "Hello! This is a test message from the Webhook."}

response = requests.post(webhook_url, json=message)
print(response.status_code, response.text)

"""# Main

## Working Alert send Slack
Input:
- Utilization
- Risk Factor
- Sentiment Factor
"""

import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from slack_sdk.webhook import WebhookClient

# Load pre-trained model
def train_model():
    # Load the dataset
    data = pd.read_csv("supply_chain_alerts.csv")

    # Convert categorical target variable into numeric
    data['Action'] = data['Action'].map({'SELL': 0, 'MONITOR': 1, 'BUY': 2})

    # Select features and target
    X = data[['Utilization', 'Risk Score', 'Sentiment Score']]
    y = data['Action']

    # Train the Random Forest model
    model = RandomForestClassifier(random_state=42)
    model.fit(X, y)
    return model

# Initialize Slack Webhook
slack_webhook_url = "https://hooks.slack.com/services/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"
slack_client = WebhookClient(slack_webhook_url)

# Function to send Slack alert
def send_slack_alert(action, message):
    actions = {
        "SELL": ":warning: *SELL Alert!*",
        "MONITOR": ":mag: *Monitor Alert!*",
        "BUY": ":shopping_cart: *BUY Alert!*"
    }
    slack_message = f"{actions[action]}\n{message}"
    response = slack_client.send(text=slack_message)
    if response.status_code == 200:
        print("Slack alert sent successfully!")
    else:
        print("Failed to send Slack alert.")

# Main Function to process input and send alerts
def main():
    # Train or load the model
    model = train_model()

    # User input
    user_input = {
        'Utilization': float(input("Enter Utilization (e.g., 0.85): ")),
        'Risk Score': float(input("Enter Risk Score (e.g., 9.5): ")),
        'Sentiment Score': float(input("Enter Sentiment Score (e.g., 5.0): "))
    }

    # Convert input to DataFrame for prediction
    new_input = pd.DataFrame([user_input])

    # Predict action
    prediction = model.predict(new_input)[0]
    action_map = {0: 'SELL', 1: 'MONITOR', 2: 'BUY'}
    action = action_map[prediction]

    # Prepare alert message
    alert_message = f"Predicted Action: {action}\nDetails:\n- Utilization: {user_input['Utilization']}\n" \
                    f"- Risk Score: {user_input['Risk Score']}\n- Sentiment Score: {user_input['Sentiment Score']}"

    # Send alert via Slack
    send_slack_alert(action, alert_message)

if __name__ == "__main__":
    main()

"""## Final Alert send Slack
Input:
- Inventory
- Lead Time (days)
- Transport Status
- News Sentiment
- Weather Conditio
- Slack Incoming Webhook URL
"""

import requests
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from transformers import pipeline

# 1. Initialize Sentiment and Risk Models
def initialize_sentiment_model():
    return pipeline("sentiment-analysis", model="cardiffnlp/twitter-roberta-base-sentiment")

def initialize_risk_model():
    return pipeline("text-classification", model="facebook/bart-large-mnli")

# 2. Calculate Risk Score, Sentiment Score, and Utilization
def analyze_data(inventory, lead_time, transport_status, news_sentiment, weather_condition, sentiment_model, risk_model):
    # Calculate utilization
    utilization = inventory / 10000  # Assuming max capacity is 10,000 units for all regions

    # Sentiment Analysis
    sentiment_result = sentiment_model(news_sentiment)
    sentiment_label = sentiment_result[0]['label']
    sentiment_score = sentiment_result[0]['score']

    # Risk Analysis
    risk_context = f"News: {news_sentiment}. Transport Status: {transport_status}. Weather: {weather_condition}. Inventory: {inventory}. Lead Time: {lead_time}."
    risk_result = risk_model(risk_context)
    risk_label = risk_result[0]['label']
    risk_score = risk_result[0]['score']

    return utilization, sentiment_label, sentiment_score, risk_label, risk_score

# 3. Train the Model
def train_model(data_path):
    data = pd.read_csv(data_path)

    # Map target variable to numeric
    data['Action'] = data['Action'].map({'SELL': 0, 'MONITOR': 1, 'BUY': 2})

    # Select features and target
    X = data[['Utilization', 'Risk Score', 'Sentiment Score']]
    y = data['Action']

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Train model
    model = RandomForestClassifier(random_state=42)
    model.fit(X_train, y_train)

    # Evaluate model
    y_pred = model.predict(X_test)
    print("Model Trained. Evaluation:\n", classification_report(y_test, y_pred))

    return model

# 4. Predict Action
def predict_action(model, utilization, risk_score, sentiment_score):
    new_input = pd.DataFrame({
        'Utilization': [utilization],
        'Risk Score': [risk_score],
        'Sentiment Score': [sentiment_score]
    })
    prediction = model.predict(new_input)
    action_map = {0: 'SELL', 1: 'MONITOR', 2: 'BUY'}
    return action_map[prediction[0]]

# 5. Send Slack Alert
def send_slack_alert(webhook_url, message):
    payload = {
        "text": message
    }
    try:
        response = requests.post(webhook_url, json=payload)
        if response.status_code == 200:
            print("Alert sent to Slack successfully.")
        else:
            print(f"Failed to send alert to Slack. Status Code: {response.status_code}, Response: {response.text}")
    except Exception as e:
        print(f"Error sending Slack alert: {e}")

# 6. Main Function to Integrate All Steps
def main():
    # Initialize sentiment and risk models
    sentiment_model = initialize_sentiment_model()
    risk_model = initialize_risk_model()

    # Train the action prediction model
    model = train_model("/content/supply_chain_alerts.csv")

    # User inputs
    print("Enter Supply Chain Data:")
    inventory = int(input("Inventory (e.g., 5000): "))
    lead_time = int(input("Lead Time (days): "))
    transport_status = input("Transport Status (e.g., Delayed, In Transit, Awaiting Dispatch): ")
    news_sentiment = input("News Sentiment (e.g., Tomato prices soar due to unexpected frost in the region.\nFarmers report higher yields thanks to favorable weather.\nDelays in transportation cause supply chain disruptions.\nGovernment announces subsidies for tomato farmers.\nPest infestation reduces tomato output in key regions.\nHeavy rainfall damages crops in major producing areas.\nDrought conditions lead to reduced tomato supply.\nImproved infrastructure reduces transportation delays.\nLabor shortages affect harvesting in rural areas.\nExport restrictions lead to surplus in local markets.): ")
    weather_condition = input("Weather Condition (e.g., Sunny and favorable for farming.\nHeavy rainfall causing waterlogging\nDrought leading to crop failure.\nMild rainfall aiding crop growth.\nUnexpected frost damaging crops,\nHigh humidity increasing pest risks,\nStrong winds causing crop damage): ")

    # Slack Webhook URL
    webhook_url = input("Enter your Slack Incoming Webhook URL: ")

    # Analyze data
    utilization, sentiment_label, sentiment_score, risk_label, risk_score = analyze_data(
        inventory, lead_time, transport_status, news_sentiment, weather_condition, sentiment_model, risk_model
    )

    # Predict action
    action = predict_action(model, utilization, risk_score, sentiment_score)

    # Create Slack message content
    alert_message = (
        f"*Supply Chain Alert: Recommended Action - {action}*\n"
        f"Utilization: {utilization}\n"
        f"Risk Score: {risk_score}\n"
        f"Sentiment Score: {sentiment_score}\n"
        f"\n*Details:*\n"
        f"- *Inventory:* {inventory}\n"
        f"- *Lead Time:* {lead_time}\n"
        f"- *Transport Status:* {transport_status}\n"
        f"- *News Sentiment:* {news_sentiment}\n"
        f"- *Weather Condition:* {weather_condition}\n"
        f"- *Utilization:* {utilization:.2f}\n"
        f"- *Sentiment:* {sentiment_label} (Score: {sentiment_score:.2f})\n"
        f"- *Risk:* {risk_label} (Score: {risk_score:.2f})"
    )

    # Send Slack alert
    send_slack_alert(webhook_url, alert_message)

if __name__ == "__main__":
    main()



"""# Dashboard"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from IPython.core.display import display, HTML

# Sample dataset for Supply Chain Management
data = {
    "Inventory": [4500, 8500, 3000, 6200, 9100],
    "Lead Time (days)": [12, 7, 20, 15, 5],
    "Transport Status": ["Delayed", "In Transit", "Awaiting Dispatch", "In Transit", "Delayed"],
    "News Sentiment": ["Negative", "Positive", "Neutral", "Positive", "Negative"],
    "Weather Condition": ["Adverse", "Favorable", "Adverse", "Favorable", "Adverse"],
    "Risk Score": [8.7, 2.3, 6.5, 3.2, 9.1],
    "Sentiment Score": [4.5, 8.9, 6.0, 7.5, 3.2],
    "Recommended Action": ["SELL", "MONITOR", "RESTOCK", "MONITOR", "SELL"]
}

# Convert data to a DataFrame
df = pd.DataFrame(data)

# Generate the HTML Table
html_table = df.to_html(index=False, classes='supply-chain-table', border=0, justify="center")

# CSS Styling for the table
html_style = """
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f9f9f9;
    }
    .container {
        max-width: 800px;
        margin: auto;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }
    .header {
        text-align: center;
        margin-bottom: 20px;
    }
    .header h1 {
        font-size: 2rem;
        color: #333;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 10px;
        text-align: center;
    }
    th {
        background-color: #4CAF50;
        color: white;
    }
    .action {
        font-weight: bold;
        color: red;
    }
</style>
"""

# Complete HTML content
html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supply Chain Dashboard</title>
    {html_style}
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Supply Chain Dashboard</h1>
        </div>
        {html_table}
    </div>
</body>
</html>
"""

# Display HTML Table
display(HTML(html_content))

# Generate Visualizations

# Inventory vs. Risk Score
sns.set(style="whitegrid")
plt.figure(figsize=(8, 6))
sns.barplot(x="Inventory", y="Risk Score", data=df, palette="viridis")
plt.title("Inventory vs. Risk Score")
plt.show()

# Risk Score Distribution
plt.figure(figsize=(8, 6))
sns.histplot(df["Risk Score"], kde=True, color="blue", bins=10)
plt.title("Risk Score Distribution")
plt.xlabel("Risk Score")
plt.ylabel("Frequency")
plt.show()

# Pie Chart for Transport Status
plt.figure(figsize=(6, 6))
df["Transport Status"].value_counts().plot.pie(autopct="%.1f%%", colors=sns.color_palette("pastel"))
plt.title("Transport Status Distribution")
plt.ylabel("")  # Remove y-label for better appearance
plt.show()

"""## use sample data"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from IPython.core.display import display, HTML

# Function to generate dashboard and visualizations
def generate_dashboard(data):
    # Convert input data into a DataFrame for easy visualization
    df = pd.DataFrame([data])

    # Display the data in a table format
    html_table = df.to_html(index=False, classes="supply-chain-table", border=0, justify="center")

    # HTML Styling for the table
    html_style = """
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color:  #1e1e2f;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            font-size: 2rem;
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        .action {
            font-weight: bold;
            color: red;
        }
    </style>
    """

    # Combine HTML content
    html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Supply Chain Dashboard</title>
        {html_style}
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>Supply Chain Dashboard</h1>
            </div>
            {html_table}
        </div>
    </body>
    </html>
    """

    # Display the table
    display(HTML(html_content))

    # Generate visualizations
    sns.set(style="whitegrid")
    plt.figure(figsize=(8, 6))
    sns.barplot(x=["Utilization", "Risk Score", "Sentiment Score"], y=[data["Utilization"], data["Risk Score"], data["Sentiment Score"]])
    plt.title("Utilization, Risk Score, and Sentiment Score")
    plt.ylabel("Value")
    plt.show()

    plt.figure(figsize=(8, 6))
    sns.histplot([data["Utilization"], data["Risk Score"], data["Sentiment Score"]], bins=5, kde=True, color="blue")
    plt.title("Distribution of Key Metrics")
    plt.xlabel("Metric Values")
    plt.ylabel("Frequency")
    plt.show()

# Function to collect real-time data from the user
def collect_user_data():
    print("Enter Supply Chain Data:")
    inventory = int(input("\nInventory (e.g., 5000): "))
    lead_time = int(input("\nLead Time (days): "))
    transport_status = input("\nTransport Status (e.g., Delayed, In Transit, Awaiting Dispatch): ")
    news_sentiment = input("\nNews Sentiment (e.g., Negative, Positive, Neutral): ")
    weather_condition = input("\nWeather Condition (e.g., Adverse, Favorable): ")

    # Mock utilization, sentiment score, and risk score calculation
    utilization = inventory / 10000  # Assuming max capacity is 10,000 units for all regions
    sentiment_score = len(news_sentiment) * 0.1  # Example sentiment score calculation
    risk_score = len(weather_condition) * 0.2  # Example risk score calculation
    action = "SELL" if risk_score > 5 else "MONITOR" if risk_score > 3 else "BUY"

    # Return user data as a dictionary
    return {
        "Inventory": inventory,
        "Lead Time (days)": lead_time,
        "Transport Status": transport_status,
        "News Sentiment": news_sentiment,
        "Weather Condition": weather_condition,
        "Utilization": utilization,
        "Risk Score": risk_score,
        "Sentiment Score": sentiment_score,
        "Action": action
    }

# Main function to update dashboard based on user inputs
def main():
    while True:
        print("\n--- Real-Time Supply Chain Dashboard ---")
        user_data = collect_user_data()  # Get real-time user inputs
        generate_dashboard(user_data)   # Update dashboard
        cont = input("\nDo you want to enter more data? (yes/no): ").lower()
        if cont != 'yes':
            break

# Run the program
main()

"""## Use Dynamic data"""

import requests
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from transformers import pipeline
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.core.display import display, HTML

# 1. Initialize Sentiment and Risk Models
def initialize_sentiment_model():
    return pipeline("sentiment-analysis", model="cardiffnlp/twitter-roberta-base-sentiment")

def initialize_risk_model():
    return pipeline("text-classification", model="facebook/bart-large-mnli")

# 2. Analyze Data
def analyze_data(inventory, lead_time, transport_status, news_sentiment, weather_condition, sentiment_model, risk_model):
    utilization = inventory / 10000  # Assuming max capacity is 10,000 units

    # Sentiment Analysis
    sentiment_result = sentiment_model(news_sentiment)
    sentiment_label = sentiment_result[0]['label']
    sentiment_score = sentiment_result[0]['score']

    # Risk Analysis
    risk_context = f"News: {news_sentiment}. Transport Status: {transport_status}. Weather: {weather_condition}. Inventory: {inventory}. Lead Time: {lead_time}."
    risk_result = risk_model(risk_context)
    risk_label = risk_result[0]['label']
    risk_score = risk_result[0]['score']

    return utilization, sentiment_label, sentiment_score, risk_label, risk_score

# 3. Train the Model
def train_model(data_path):
    data = pd.read_csv(data_path)
    data['Action'] = data['Action'].map({'SELL': 0, 'MONITOR': 1, 'BUY': 2})
    X = data[['Utilization', 'Risk Score', 'Sentiment Score']]
    y = data['Action']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    model = RandomForestClassifier(random_state=42)
    model.fit(X_train, y_train)
    print("Model Trained. Evaluation:\n", classification_report(y_test, model.predict(X_test)))
    return model

# 4. Predict Action
def predict_action(model, utilization, risk_score, sentiment_score):
    new_input = pd.DataFrame({'Utilization': [utilization], 'Risk Score': [risk_score], 'Sentiment Score': [sentiment_score]})
    prediction = model.predict(new_input)
    action_map = {0: 'SELL', 1: 'MONITOR', 2: 'BUY'}
    return action_map[prediction[0]]

# 5. Send Slack Alert
def send_slack_alert(webhook_url, message):
    payload = {"text": message}
    try:
        response = requests.post(webhook_url, json=payload)
        if response.status_code == 200:
            print("Alert sent to Slack successfully.")
        else:
            print(f"Failed to send alert. Status Code: {response.status_code}, Response: {response.text}")
    except Exception as e:
        print(f"Error sending Slack alert: {e}")

# 6. Generate Dashboard and Visualizations
def generate_dashboard(data):
    # Convert the data to a Pandas DataFrame
    df = pd.DataFrame([data])

    # Create an enhanced HTML table with additional styling
    html_table = df.to_html(index=False, classes="supply-chain-table", border=0, justify="center")

    html_style = html_style = """
    <style>
        body {
            font-family: 'Poppins', Arial, sans-serif; /* Modern font */
            background-color: #121212; /* Dark background */
            color: #e0e0e0; /* Light text color for readability */
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 900px;
            margin: 30px auto;
            background: linear-gradient(145deg, #1e1e2f, #232336); /* Subtle gradient */
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            color: #ffffff; /* Header text in white */
            font-size: 2rem; /* Larger text size */
            font-weight: bold;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Soft shadow around table */
        }
        th, td {
            padding: 15px;
            text-align: center;
            font-size: 0.9rem;
        }
        th {
            background: linear-gradient(145deg, #007BFF, #0056b3); /* Gradient header */
            color: #ffffff; /* White text */
            text-transform: uppercase; /* Capitalize headers */
            letter-spacing: 0.05rem; /* Slightly spaced text */
        }
        td {
            background-color: #1e1e2f; /* Dark cell background */
            color: #e0e0e0; /* Light cell text */
        }
        tr:nth-child(even) td {
            background-color: #2a2a3a; /* Slightly lighter for zebra effect */
        }
        tr:hover td {
            background-color: #34344a; /* Highlight row on hover */
            color: #ffffff; /* Brighten text on hover */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        a {
            color: #007BFF; /* Link color */
            text-decoration: none;
        }
        a:hover {
            color: #0056b3; /* Darker link on hover */
            text-decoration: underline;
        }
    </style>
"""

    # Combine the styles and the table into HTML content
    html_content = f"""
    <html>
        <head><title>Enhanced Dashboard</title>{html_style}</head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>Supply Chain Dashboard</h1>
                </div>
                {html_table}
            </div>
        </body>
    </html>
    """

    # Display the HTML dashboard
    display(HTML(html_content))

    # Generate Enhanced Visualizations
    sns.set_theme(style="whitegrid")

    # Barplot for Key Metrics
    plt.figure(figsize=(10, 6))
    sns.barplot(
        x=["Utilization", "Risk Score", "Sentiment Score"],
        y=[data["Utilization"], data["Risk Score"], data["Sentiment Score"],],
        palette="coolwarm"
    )
    plt.title("Utilization, Risk Score, and Sentiment Score", fontsize=16)
    plt.ylabel("Values", fontsize=12)
    plt.xlabel("Metrics", fontsize=12)
    plt.xticks(fontsize=11)
    plt.yticks(fontsize=11)
    plt.show()

# 7. Collect Real-Time User Data
def collect_user_data(sentiment_model, risk_model, action_model, webhook_url):
    inventory = int(input("\nInventory (e.g., 5000): "))
    lead_time = int(input("Lead Time (days): "))
    transport_status = input("Transport Status (e.g., Delayed, In Transit): ")
    news_sentiment = input("News Sentiment: ")
    weather_condition = input("Weather Condition: ")

    utilization, sentiment_label, sentiment_score, risk_label, risk_score = analyze_data(
        inventory, lead_time, transport_status, news_sentiment, weather_condition, sentiment_model, risk_model
    )
    action = predict_action(action_model, utilization, risk_score, sentiment_score)

    alert_message = f"""
    *Supply Chain Alert: Recommended Action - {action}*
    - Inventory: {inventory}
    - Lead Time: {lead_time}
    - Transport Status: {transport_status}
    - News Sentiment: {news_sentiment}
    - Weather Condition: {weather_condition}
    - Utilization: {utilization:.2f}
    - Sentiment: {sentiment_label} (Score: {sentiment_score:.2f})
    - Risk: {risk_label} (Score: {risk_score:.2f})
    """

    send_slack_alert(webhook_url, alert_message)
    return {
        "Inventory": inventory,
        "Lead Time": lead_time,
        "Transport Status": transport_status,
        "News Sentiment": news_sentiment,
        "Weather Condition": weather_condition,
        "Utilization": utilization,
        "Sentiment Score": sentiment_score,
        "Risk Score": risk_score,
        "Action": action
    }

# 8. Main Function
def main():
    sentiment_model = initialize_sentiment_model()
    risk_model = initialize_risk_model()
    action_model = train_model("/content/supply_chain_alerts.csv")  # Replace with your dataset
    webhook_url = input("\nEnter your Slack Webhook URL: ")

    while True:
        user_data = collect_user_data(sentiment_model, risk_model, action_model, webhook_url)
        generate_dashboard(user_data)
        cont = input("\nDo you want to enter more data? (yes/no): ").lower()
        if cont != 'yes':
            break

# Run the program
if __name__ == "__main__":
    main()